{
  "method_design": [
    "# グローバルメソッド設計書qe",
    "メソッド一覧",
    "",
    "----",
    "- convert_gijiroku_to_docx",
    "- convert_expected_qa_to_xslx",
    "- convert_to_docx_data",
    "- add_separator_line",
    "- qa_merge",
    "- create_qa",
    "- transform_comment_data",
    "- transform_expected_qas_data",
    "- load_existing_data",
    "- generate_file_id",
    "- check_access_privileges",
    "- get_menu",
    "- get_take_minutes",
    "- fetch_expected_qa_list",
    "- get_meeting_summary",
    "- get_meeting_summary_result",
    "- get_expected_QA",
    "- get_expected_QA_result",
    "- download_task_file",
    "- post_login",
    "- encrypt_bytes",
    "- decrypt_bytes",
    "- encrypt_access_info",
    "- check_access_info",
    "- extract_speakers",
    "- is_qa_relevent",
    "- transcribe_audio_cloud",
    "- create_gijiroku_data",
    "- identify_topics_in_qa_pairs",
    "- extract_comments",
    "- fix_conv_format",
    "- extract_qa_pairs",
    "- transform_qa_to_report",
    "- convert_format",
    "- clean_up",
    "- extract_audio_track",
    "- health_check_local_server",
    "- speech_to_text_local_server",
    "- speech_to_text_azure",
    "- speech_to_text----",
    "## convert_gijiroku_to_docx",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、IRミーティングの議事録データ（GijirokuData型）を受け取り、Word文書（docx形式）のDocumentオブジェクトとして整形・出力します。議事録のタイトル、基本情報（音声ファイル名、音声の長さ、作成日付）、今後の改善点・要望、投資家フィードバック（ポジティブ・ネガティブ）、QA一覧をWord文書の各セクションとして追加します。各セクションは適切なフォントサイズや太字などの書式設定が施され、コメントやQAはリスト形式で表示されます。QAの回答が複数ある場合は箇条書きで表示され、各QAの区切り線も追加されます。関数はDocumentオブジェクトを返すため、呼び出し元で保存や他の処理が可能です。",
    "",
    "エッジケースとして、コメントやQAが空の場合は「なし」と表示されます。データの各フィールドが未定義または不正な型の場合、例外が発生する可能性があります。関数は直接呼び出して使用し、引数としてGijirokuData型のデータを渡します。",
    "### 入力",
    "",
    "---",
    "  - data: GijirokuData",
    "  例:",
    "```python",
    "{",
    "    \"file_name\": \"meeting_audio.mp3\",",
    "    \"audio_length\": \"01:23:45\",",
    "    \"created_date\": \"2024-06-01\",",
    "    \"feedback\": [",
    "        {",
    "            \"comment\": \"発言が明確で分かりやすかったです。\",",
    "            \"author\": \"田中\",",
    "            \"timestamp\": \"00:15:30\"",
    "        }",
    "    ],",
    "    \"positive_comments\": [",
    "        {",
    "            \"comment\": \"議論が活発で良かったです。\",",
    "            \"author\": \"佐藤\",",
    "            \"timestamp\": \"00:45:10\"",
    "        }",
    "    ],",
    "    \"negative_comments\": [",
    "        {",
    "            \"comment\": \"一部の議題が時間内に終わりませんでした。\",",
    "            \"author\": \"鈴木\",",
    "            \"timestamp\": \"01:10:05\"",
    "        }",
    "    ],",
    "    \"qa\": [",
    "        {",
    "            \"question\": \"次回の会議はいつですか？\",",
    "            \"answer\": \"2024-06-15に予定されています。\",",
    "            \"asked_by\": \"山本\",",
    "            \"answered_by\": \"田中\"",
    "        }",
    "    ]",
    "}",
    "```",
    "### 出力",
    "",
    "---",
    "Document型のWord文書オブジェクト。例：IRミーティングの議事録が整形された.docxファイルとして保存可能なDocumentインスタンス。",
    "",
    "----",
    "## convert_expected_qa_to_xslx",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、ExpectedQAData型のdataオブジェクトを受け取り、その中のqa属性（カテゴリ・サブカテゴリごとのQAリスト）をExcelワークブック（openpyxlのWorkbook）に変換します。各QA項目は「大分類」「小分類」「想定質問」「推奨回答」の4列に分けてシートに追加されます。推奨回答が複数ある場合は、各回答の前に「・」を付けて改行区切りで1セルにまとめます。Excelのテーブル形式（Table）でスタイルも適用されます。関数は直接呼び出すことで、Excelワークブックを生成し、ファイル保存や他処理に利用できます。エッジケースとして、data.qaが空の場合はヘッダーのみのシートが返されます。また、qa.answerが空リストの場合は空文字列がセルに入ります。",
    "### 入力",
    "",
    "---",
    "  - data: ExpectedQAData",
    "  例:",
    "```python",
    "{",
    "    \"カテゴリA\": {",
    "        \"サブカテゴリ1\": [",
    "            {",
    "                \"question\": \"質問1\",",
    "                \"answer\": [",
    "                    \"回答1\"",
    "                ]",
    "            }",
    "        ]",
    "    }",
    "}",
    "```",
    "### 出力",
    "",
    "---",
    "openpyxlのWorkbookオブジェクト。例えば、Excelファイルとして保存可能なワークブックで、シートには「大分類」「小分類」「想定質問」「推奨回答」の列があり、各QAデータが行として格納されています。",
    "",
    "----",
    "## convert_to_docx_data",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、引数としてGijirokuData型またはExpectedQAData型のデータを受け取り、その型に応じて適切な変換処理を行います。GijirokuData型の場合はconvert_gijiroku_to_docx関数を呼び出してdocxドキュメントを生成し、ExpectedQAData型の場合はconvert_expected_qa_to_xslx関数を呼び出してxlsxドキュメントを生成します。生成されたドキュメントはio.BytesIOを用いてバイト列に変換され、そのバイナリデータが返されます。",
    "",
    "呼び出し方法は、dataにGijirokuDataまたはExpectedQADataのインスタンスを渡して関数を実行します。",
    "",
    "エッジケースとして、dataがGijirokuDataでもExpectedQADataでもない場合は、どちらの変換関数も呼ばれず、AttributeErrorやTypeErrorが発生する可能性があります。また、変換対象のデータが不正（必須フィールドが欠落している、内部構造が壊れている等）の場合、変換関数内で例外が発生することがあります。",
    "",
    "入力パラメータは1つで、型によって処理が分岐します。返り値はdocxまたはxlsxファイルのバイナリデータ（bytes型）です。",
    "### 入力",
    "",
    "---",
    "  - data: GijirokuData | ExpectedQAData",
    "  例:",
    "```python",
    "{",
    "    \"meeting_id\": \"20240601-001\",",
    "    \"participants\": [",
    "        {",
    "            \"name\": \"田中\",",
    "            \"role\": \"司会\"",
    "        },",
    "        {",
    "            \"name\": \"佐藤\",",
    "            \"role\": \"発言者\"",
    "        }",
    "    ],",
    "    \"statements\": [",
    "        {",
    "            \"speaker\": \"田中\",",
    "            \"timestamp\": \"10:00\",",
    "            \"content\": \"本日の議題について説明します。\"",
    "        },",
    "        {",
    "            \"speaker\": \"佐藤\",",
    "            \"timestamp\": \"10:05\",",
    "            \"content\": \"質問があります。\"",
    "        }",
    "    ],",
    "    \"comments\": [",
    "        {",
    "            \"author\": \"佐藤\",",
    "            \"content\": \"議事録の内容を確認しました。\"",
    "        }",
    "    ]",
    "}",
    "```",
    "### 出力",
    "",
    "---",
    "バイト列（bytes型）。生成されたdocxファイルまたはxlsxファイルのバイナリデータ。例：b'PK\\x03\\x04...（docx/xlsxファイルのバイナリデータ）'",
    "",
    "----",
    "## add_separator_line",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、python-docxライブラリのParagraphオブジェクトに対して、Word文書の段落下部に区切り線（下線）を追加します。段落の内部XML要素に直接アクセスし、段落プロパティ（pPr）に境界線（pBdr）要素を挿入し、その中に下線（bottom）要素を追加します。下線の種類は'single'、太さは6、余白は1、色は'auto'で設定されます。関数はparagraph._elementを操作するため、python-docxのParagraphオブジェクトのみを受け付けます。呼び出しはadd_separator_line(paragraph)のように行います。段落が既にpPrやpBdrを持っている場合でも、重複して追加される可能性があるため、複数回呼び出すと区切り線が重複することがあります。paragraphがNoneやParagraph以外の場合、または内部XML構造が破損している場合は例外が発生します。",
    "### 入力",
    "",
    "---",
    "  - paragraph: docx.text.paragraph.Paragraph",
    "### 出力",
    "",
    "---",
    "なし",
    "",
    "----",
    "## qa_merge",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "qa_merge関数は、複数のQAペア（質問と回答のセット）のリストを1つのリストに統合するためのメソッドです。入力として、List[List[Dict[str, str]]]型のqa_listを受け取ります。qa_listが1つのリストのみの場合は、そのまま返します。2つ以上のリストが与えられた場合は、QAMergeクラスを用いてマージ処理を行い、統合されたQAリストを返します。主に、複数の異なるソースやカテゴリから収集したQAデータを1つにまとめる用途で利用されます。エッジケースとして、qa_listが空の場合や、内部のリストが空の場合は、QAMergeの実装に依存しますが、通常は空リストが返されることが想定されます。呼び出しは、qa_merge(qa_list)のように行います。",
    "### 入力",
    "",
    "---",
    "  - qa_list: List[List[Dict[str, str]]]",
    "  例:",
    "```python",
    "[",
    "    [",
    "        {",
    "            \"question\": \"A?\",",
    "            \"answer\": \"B\"",
    "        }",
    "    ],",
    "    [",
    "        {",
    "            \"question\": \"C?\",",
    "            \"answer\": \"D\"",
    "        }",
    "    ]",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "マージされたQAペアのリスト。各要素は辞書で、\"question\"と\"answer\"のキーを持つ（例：[{\"question\": \"2024年度の業績予測は？\", \"answer\": \"売上高は前年比10%増を見込んでいます。\"}, {\"question\": \"セグメント別の業績予測は？\", \"answer\": \"A事業は15%増、B事業は横ばいです。\"}])。",
    "",
    "----",
    "## create_qa",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このメソッドは、PDFファイルのパスを受け取り、そのファイルからQA（質問応答）データを生成し、結果をJSONファイルとして保存します。内部的にはQACreatorクラスのインスタンスを生成し、そのcreateメソッドを呼び出すことでQA生成処理を実行します。主にPDFから自動的にQAデータを作成したい場合に利用されます。ファイルパスが不正な場合や、PDFの内容が読み取れない場合、またはQACreatorの内部処理で例外が発生した場合はエラーとなります。正常に処理が完了した場合は、生成されたQAのJSONファイルパスを返します。",
    "### 入力",
    "",
    "---",
    "  - file_path: str",
    "### 出力",
    "",
    "---",
    "QAの内容が格納されたJSONファイルのパスを表す文字列。例: '/home/user/data/financial_report_qa.json'",
    "",
    "----",
    "## transform_comment_data",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、会議コメントデータ（original_data）を受け取り、各コメントを'発言者'（class）と'カテゴリ'（category）ごとにグループ化したネストされた辞書に変換します。各コメントの'content'（内容）と'topic'（トピック）を抽出し、class→category→コメントリストの構造で格納します。主な用途は、会議記録や議事録生成時に、発言者ごと・カテゴリごとにコメントを整理することです。関数は直接呼び出し可能で、引数original_dataには、'class', 'category', 'content', 'topic'を含む辞書のリストを渡します。エッジケースとして、original_dataが空の場合は空の辞書を返します。また、各itemに'class', 'category', 'content', 'topic'が存在しない場合、KeyErrorが発生します。重複するclassやcategoryがあっても、正しくリストに追加されます。",
    "### 入力",
    "",
    "---",
    "  - original_data: List[Dict[str, Any]]",
    "  例:",
    "```python",
    "[",
    "    {",
    "        \"class\": \"発言者A\",",
    "        \"category\": \"質問\",",
    "        \"content\": \"この議題について質問があります。\",",
    "        \"topic\": \"議題1\"",
    "    },",
    "    {",
    "        \"class\": \"発言者B\",",
    "        \"category\": \"コメント\",",
    "        \"content\": \"議題1について意見があります。\",",
    "        \"topic\": \"議題1\"",
    "    }",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "classごと、かつcategoryごとにコメント内容とトピックをまとめたネストされた辞書。例: {'発言者A': {'質問': [{'content': 'この議題について質問があります。', 'topic': '議題1'}]}, '発言者B': {'コメント': [{'content': '議題1について意見があります。', 'topic': '議題1'}]}}",
    "",
    "----",
    "## transform_expected_qas_data",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、QAデータ（質問・回答のペア）をカテゴリごとにグループ化して辞書形式で返します。入力は、'category', 'question', 'answer'を持つ辞書のリストです。各カテゴリごとに、対応する質問・回答のペアをリストとしてまとめます。主に、QAデータをフロントエンドやテンプレートでカテゴリ別に表示したい場合に利用されます。関数は直接呼び出して利用します。エッジケースとして、入力リストが空の場合は空の辞書を返します。また、各アイテムに'category', 'question', 'answer'が存在しない場合はKeyError例外が発生します。カテゴリが重複している場合は、同じカテゴリのリストに追加されます。",
    "### 入力",
    "",
    "---",
    "  - oringinal_data: List[Dict[str, str]]",
    "  例:",
    "```python",
    "[",
    "    {",
    "        \"category\": \"技術\",",
    "        \"question\": \"APIの認証方法は？\",",
    "        \"answer\": \"OAuth2を使用しています。\"",
    "    },",
    "    {",
    "        \"category\": \"運用\",",
    "        \"question\": \"バックアップの頻度は？\",",
    "        \"answer\": \"毎日実施しています。\"",
    "    }",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "カテゴリごとにQAをまとめた辞書。キーはカテゴリ名（str）、値は質問・回答のペア（List[Dict[str, str]]）のリスト。例: {'技術': [{'question': 'APIの認証方法は？', 'answer': 'OAuth2を使用しています。'}], '運用': [{'question': 'バックアップの頻度は？', 'answer': '毎日実施しています。'}]}",
    "",
    "----",
    "## load_existing_data",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、指定されたファイルパスに存在するJSONファイルを読み込み、その内容をPythonのリスト（各要素は辞書型）として返します。主に議事録やQAデータなど、ファイルIDや関連情報を保存したJSONファイルの読み込みに利用されます。ファイルが存在しない場合は空のリストを返すため、呼び出し元でファイルの有無を気にせず利用できます。エッジケースとして、ファイルが存在しない場合や、ファイルが空の場合は空リストが返されます。ファイルが存在していても、JSONの内容が不正（例: 構文エラー）の場合は例外が発生します。呼び出しは load_existing_data('/storage/file_data/gijiroku/file_id.json') のようにパスを指定して行います。",
    "### 入力",
    "",
    "---",
    "  - path: str",
    "### 出力",
    "",
    "---",
    "List[Dict]型で、各要素はファイル内のデータ（例: {'file_id': 'abc123', 'filename': 'minutes_20240601.docx'} のような議事録ファイル情報や、{'file_id': 'qa456', 'filename': 'expected_QA_20240601.json'} のようなQAデータ情報）を表す辞書です。ファイルが存在しない場合は空リスト（[]）が返ります。",
    "",
    "----",
    "## generate_file_id",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、既存のファイル情報リスト（existing_data）を受け取り、最新のファイルIDをもとに新しいファイルIDを生成します。ファイルIDは 'FILE' に続く3桁の数字（例: 'FILE001', 'FILE002'）で構成されます。existing_data が空の場合は 'FILE001' を返します。そうでない場合は、リストの最後の要素の 'file_id' を取得し、数字部分を1増やして新しいIDを作成します。主に会議録やQAデータなど、ファイル管理のための一意なID生成に利用されます。呼び出しは他の関数やAPIエンドポイントから、ファイル保存時などに行われます。エッジケースとして、existing_data が空の場合は必ず 'FILE001' を返し、'file_id' キーが存在しない場合や不正な形式の場合は例外が発生します。",
    "### 入力",
    "",
    "---",
    "  - existing_data: List[Dict[str, Any]]",
    "  例:",
    "```python",
    "[",
    "    {",
    "        \"file_id\": \"FILE001\",",
    "        \"filename\": \"minutes1.docx\"",
    "    },",
    "    {",
    "        \"file_id\": \"FILE002\",",
    "        \"filename\": \"minutes2.docx\"",
    "    }",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "新しく生成されたファイルID（例: 'FILE003'）。既存データが空の場合は 'FILE001' を返します。",
    "",
    "----",
    "## check_access_privileges",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このミドルウェアは、FastAPIアプリケーションの全てのHTTPリクエストに対してアクセス権限を検証します。環境変数REQUIRE_LOGINが'1'の場合、認証が必要となり、未認証のユーザーは'/login'ページへリダイレクトされます。認証済みかどうかは、Cookieの'session_id'をSessionManagerのis_verifiedメソッドで判定します。'/login'や'/favicon.ico'へのリクエストは常に通過させます。未認証の場合、'pre_login_url'というCookieに元のリクエストパスを保存し、無効なsession_idはCookieから削除します。認証済みの場合や認証不要の場合は、通常通り次の処理へ進み、最終的に'response'から'pre_login_url' Cookieを削除して返します。エッジケースとして、REQUIRE_LOGINが'0'で'/login'にアクセスした場合はトップページへリダイレクトされます。session_idが不正な場合はCookieから削除されます。",
    "### 入力",
    "",
    "---",
    "  - request: Request",
    "  - call_next: Callable",
    "  例:",
    "```python",
    "{",
    "    \"url\": {",
    "        \"path\": \"/login\"",
    "    },",
    "    \"cookies\": {",
    "        \"session_id\": \"abc123\"",
    "    }",
    "}",
    "```",
    "### 出力",
    "",
    "---",
    "FastAPIのResponseオブジェクト。リダイレクトや通常のレスポンスを返します。例: RedirectResponse(url='/login', status_code=303)や、通常のHTML/JSONレスポンス。",
    "",
    "----",
    "## get_menu",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このメソッドはFastAPIのGETエンドポイント'/login'に紐付けられており、ユーザーがログインページにアクセスした際に呼び出されます。引数としてFastAPIのRequestオブジェクトを受け取り、Jinja2テンプレートエンジンを用いてlogin.htmlをレンダリングし、リクエスト情報をコンテキストとして渡します。主な目的は、ログイン画面を表示することです。エッジケースとして、テンプレートファイル（login.html）が存在しない場合やテンプレートレンダリング時にエラーが発生した場合は、500エラーが返される可能性があります。通常は例外処理は行われていませんが、FastAPI/Jinja2の内部で例外が発生した場合は自動的にエラーレスポンスが返されます。",
    "### 入力",
    "",
    "---",
    "  - req: Request",
    "  例:",
    "```python",
    "{",
    "    \"headers\": {",
    "        \"host\": \"example.com\",",
    "        \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36\",",
    "        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",",
    "        \"accept-language\": \"ja,en-US;q=0.9,en;q=0.8\",",
    "        \"cookie\": \"sessionid=abc123xyz\"",
    "    },",
    "    \"method\": \"GET\",",
    "    \"url\": \"https://example.com/login\",",
    "    \"cookies\": {",
    "        \"sessionid\": \"abc123xyz\"",
    "    },",
    "    \"client\": {",
    "        \"host\": \"192.168.1.10\",",
    "        \"port\": 54321",
    "    }",
    "}",
    "```",
    "### 出力",
    "",
    "---",
    "TemplateResponseオブジェクト。例: ユーザーが'/login'にアクセスした際、login.htmlがレンダリングされ、HTTPレスポンスとして返される。",
    "",
    "----",
    "## get_take_minutes",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このメソッドは、FastAPIのGETリクエスト（/meeting-minutes）に対応し、会議議事録ファイルの一覧を表示するHTMLページ（take_minutes.html）を返します。まず、議事録ファイルIDとファイル名を管理するJSONファイル（file_id.json）が格納されているディレクトリが存在するかを確認し、存在しない場合はディレクトリを作成します。次に、file_id.jsonファイルが存在しない場合は空の辞書を作成して保存します。その後、file_id.jsonを読み込み、ファイルIDとファイル名の対応関係（Dict[str, str]）を取得します。最後に、Jinja2テンプレート（take_minutes.html）をレンダリングし、リクエスト情報とファイル一覧をコンテキストとして返します。",
    "",
    "エッジケースとして、file_id.jsonが存在しない場合でも自動的に空ファイルを作成するため、ファイル未存在によるエラーは発生しません。また、ファイルの読み込み時にJSONの内容が空の場合は空の辞書として扱われます。",
    "",
    "このAPIは、議事録ファイルの一覧表示画面を提供するために、フロントエンドからGETリクエストで呼び出されます。",
    "### 入力",
    "",
    "---",
    "  - req: Request",
    "### 出力",
    "",
    "---",
    "TemplateResponseオブジェクト。take_minutes.htmlテンプレートがレンダリングされ、contextにはrequest情報とファイルID・ファイル名の辞書（例: {\"abc123\": \"2024年6月会議議事録.docx\", \"def456\": \"2024年5月会議議事録.docx\"}）が含まれる。",
    "",
    "----",
    "## fetch_expected_qa_list",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このメソッドは、FastAPIのGETリクエストとして '/expected-QA' エンドポイントにアクセスされた際に呼び出されます。主な目的は、期待されるQA（質問と回答）のファイルIDとファイル名の一覧を取得し、HTMLテンプレート 'expected_QA.html' に渡してWebページとして表示することです。",
    "",
    "まず、QAファイルIDを管理するJSONファイルのディレクトリが存在するか確認し、存在しない場合は新規作成します。次に、ファイルID管理用JSONファイル（QAS_FILEID_JSON_FILE_PATH）が存在しない場合は空の辞書（{}）を作成して保存します。その後、JSONファイルを読み込み、ファイルIDとファイル名のペア（例：{\"abc123\": \"QA_2024_06_01.json\"}）を取得します。",
    "",
    "取得したデータは、テンプレート 'expected_QA.html' に 'files' という名前で渡され、リクエスト情報（req）とともにWebページとして返却されます。",
    "",
    "エッジケースとして、ディレクトリやファイルが存在しない場合でも自動的に作成されるため、ファイル未存在によるエラーは発生しません。ただし、JSONファイルの内容が不正（例：破損している場合）だと例外が発生する可能性があります。",
    "",
    "このメソッドは、主に管理画面やユーザーが期待QAリストを閲覧するために利用されます。",
    "### 入力",
    "",
    "---",
    "  - req: Request",
    "  例:",
    "```python",
    "{",
    "    \"session\": {",
    "        \"user_id\": \"12345\"",
    "    },",
    "    \"headers\": {",
    "        \"Authorization\": \"Bearer abcdefg123456\",",
    "        \"User-Agent\": \"Mozilla/5.0\"",
    "    },",
    "    \"cookies\": {",
    "        \"sessionid\": \"xyz789\"",
    "    }",
    "}",
    "```",
    "### 出力",
    "",
    "---",
    "TemplateResponse: HTMLテンプレート 'expected_QA.html' をレンダリングしたレスポンス。contextには 'request'（Requestオブジェクト）と 'files'（Dict[str, str]、例：{\"abc123\": \"QA_2024_06_01.json\", \"def456\": \"QA_2024_06_02.json\"}）が含まれる。",
    "",
    "----",
    "## get_meeting_summary",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このメソッドは、FastAPIのPOSTエンドポイント '/meeting-minutes/generated-content' に紐付けられており、ユーザーが議事録ファイルをアップロードした際に呼び出されます。主な処理は以下の通りです：",
    "1. meeting_fileが空の場合は400エラーを返します。",
    "2. ファイル名・ID・作成日時をJSONファイル（file_id.json）に保存します。",
    "3. ファイルを '/storage/file_data/gijiroku/<file_id>/' ディレクトリに保存します。",
    "4. extract_comments_and_qa.create_gijiroku_data() を使い、議事録からコメントとQA情報を抽出します。",
    "5. 抽出したデータを 'comments_and_qa.json' に保存します。",
    "6. コメントデータを transform_comment_data() で変換します。",
    "7. 変換後のコメント・QA・ファイルID・ファイル名をテンプレート 'meeting_summary_result.html' に渡し、Webページとして返します。",
    "",
    "エッジケース：",
    "- meeting_fileが空の場合はエラー応答。",
    "- ファイル保存時に例外が発生した場合はエラーメッセージを出力（ただし、ユーザーへの返却は行われない）。",
    "- ディレクトリが存在しない場合は自動作成。",
    "",
    "このAPIは議事録ファイルのアップロードと要約・QA抽出を一括で行い、結果をWebページで表示するために利用されます。",
    "### 入力",
    "",
    "---",
    "  - req: Request",
    "  - meeting_file: UploadFile",
    "  例:",
    "```python",
    "{",
    "    \"req\": {",
    "        \"method\": \"POST\",",
    "        \"url\": \"/meeting-minutes/generated-content\"",
    "    },",
    "    \"meeting_file\": {",
    "        \"filename\": \"2024_06_01_meeting.txt\",",
    "        \"content_type\": \"text/plain\"",
    "    }",
    "}",
    "```",
    "### 出力",
    "",
    "---",
    "TemplateResponseオブジェクト。HTMLテンプレート 'meeting_summary_result.html' をレンダリングし、contextには以下の内容が含まれます：{\"request\": req, \"comments\": transformed_comment, \"QAs\": original_qa_data, \"file_id\": new_file_id, \"file_name\": filename}。例：commentsはList[Dict]型で、各コメントの内容や発言者情報が含まれる。QAsはList[Dict]型で、質問と回答のペアが格納される。",
    "",
    "----",
    "## get_meeting_summary_result",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このメソッドは、GETリクエストで '/meeting-minutes/generated-content/{file_id}' にアクセスされた際に呼び出されます。file_idで指定された議事録データをサーバー上のJSONファイルから読み込み、コメントとQAデータをHTMLテンプレートに渡して表示します。まず、file_idとファイル名の対応情報をJSONファイルから取得し、file_idに一致するデータを検索します。該当データがあれば、議事録データ（comments_and_qa.json）を読み込み、コメントデータをtransform_comment_data関数で整形し、テンプレートに渡します。ファイルが存在しない場合やJSONが不正な場合は、エラーメッセージを辞書形式で返します。file_idが不正な場合も同様にエラーを返します。エッジケースとして、file_idが存在しない、ファイルが削除されている、JSONが壊れている場合にそれぞれ適切なエラーを返します。",
    "### 入力",
    "",
    "---",
    "  - req: Request",
    "  - file_id: str",
    "### 出力",
    "",
    "---",
    "TemplateResponse または dict<str, str>。正常時はTemplateResponse（HTMLレンダリング結果）、エラー時は{'error': 'エラーメッセージ'}の形式の辞書。例: {'error': 'File not found: 会議議事録.docx'}",
    "",
    "----",
    "## get_expected_QA",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このメソッドは、FastAPIのPOSTエンドポイント '/expected-QA/generated-content' に対応しており、ユーザーが複数の説明資料ファイルをアップロードすると、それらをサーバー上に保存し、各ファイルからQAデータを生成・統合します。まず、ファイル名と新規ファイルID、作成日時をJSONファイルに記録します。次に、アップロードされたファイルを指定ディレクトリに保存し、expected_QA.create_qaで個別QAを生成、expected_QA.qa_mergeで統合します。統合QAデータはexpected_qas.jsonとして保存され、transform_expected_qas_dataでテンプレート表示用に変換されます。最終的に、expected_QA_result.htmlテンプレートを用いて結果を返します。ファイルが1つもアップロードされていない場合は400エラーを返します。ファイル保存時に例外が発生した場合は、エラーメッセージを記録しますが、明示的な例外送出はありません。エッジケースとして、空のファイルリストやファイル保存失敗時の処理が含まれます。",
    "### 入力",
    "",
    "---",
    "  - req: Request",
    "  - explanation_materials: List[UploadFile]",
    "  例:",
    "```python",
    "[",
    "    {",
    "        \"method\": \"POST\",",
    "        \"url\": \"https://example.com/upload\",",
    "        \"headers\": {",
    "            \"authorization\": \"Bearer abcdef123456\",",
    "            \"content-type\": \"multipart/form-data\"",
    "        },",
    "        \"user\": {",
    "            \"id\": 42,",
    "            \"name\": \"taro\"",
    "        },",
    "        \"session\": {",
    "            \"session_id\": \"xyz789\"",
    "        }",
    "    },",
    "    [",
    "        {",
    "            \"filename\": \"資料1.pdf\",",
    "            \"content_type\": \"application/pdf\",",
    "            \"content\": \"<binary data>\"",
    "        },",
    "        {",
    "            \"filename\": \"資料2.docx\",",
    "            \"content_type\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",",
    "            \"content\": \"<binary data>\"",
    "        }",
    "    ]",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "Jinja2テンプレートを用いたHTMLレスポンス。contextには、変換済みのQAデータ（expected_qas: List[Dict]）、新規ファイルID（file_id: str）、ファイル名（file_name: str）、およびリクエストオブジェクト（request: Request）が含まれる。例: {\"request\": req, \"expected_qas\": [{\"question\": \"...\", \"answer\": \"...\"}], \"file_id\": \"abc123\", \"file_name\": \"資料1.pdf,資料2.docx\"}",
    "",
    "----",
    "## get_expected_QA_result",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このメソッドは、FastAPIのGETエンドポイント '/expected-QA/generated-content/{file_id}' に対応しています。file_idで指定されたQAデータをサーバー上のJSONファイルから読み込み、transform_expected_qas_data関数で整形した後、'expected_QA_result.html'テンプレートに渡して表示します。file_idが存在しない場合や、ファイルが見つからない場合、またはJSONが不正な場合は、エラーメッセージを含む辞書を返します。主な処理の流れは、(1) file_idとファイル名の対応表JSONを読み込む、(2) file_idに一致するファイル情報を検索、(3) 該当ファイルがあればそのexpected_qas.jsonを読み込む、(4) データを整形しテンプレートで表示、(5) エラー時は辞書でエラー内容を返す、となります。エッジケースとして、file_idが存在しない場合、ファイルが物理的に存在しない場合、JSONが壊れている場合にそれぞれ異なるエラーを返します。",
    "### 入力",
    "",
    "---",
    "  - req: Request",
    "  - file_id: str",
    "### 出力",
    "",
    "---",
    "正常時はTemplateResponse（HTMLレンダリング結果）。エラー時はdict<str, str>型のエラーメッセージ。例：{'error': 'File not found: QA資料2024.docx'} または {'error': 'Invalid file_id'}",
    "",
    "----",
    "## download_task_file",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このメソッドは、GETリクエストで '/api/v1/download/{task}/{file_id}' にアクセスされた際に呼び出されます。taskパラメータで議事録（GIJIROKU）かQA（QAS）かを指定し、file_idで対象ファイルを特定します。まず、対応するJSONファイル（file_id.json）からfile_idに一致するファイル情報を検索します。該当ファイルが存在しない場合は404エラーを返します。ファイルが存在する場合は、議事録ならcomments_and_qa.json、QAならexpected_qas.jsonを読み込み、データ構造体（GijirokuDataまたはExpectedQAData）に変換します。その後、convert_to_docx_data関数でWordまたはExcelファイルのバイトデータに変換し、適切なContent-Type（Word: application/vnd.openxmlformats-officedocument.wordprocessingml.document、Excel: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet）でレスポンスとして返します。エッジケースとして、file_idが存在しない場合は404、ファイルデータの読み込み失敗時は例外が発生します。",
    "### 入力",
    "",
    "---",
    "  - req: Request",
    "  - task: IRToolTask",
    "  - file_id: str",
    "### 出力",
    "",
    "---",
    "Responseオブジェクト。Content-Typeは議事録の場合Wordファイル（.docx）、QAの場合Excelファイル（.xlsx）。例：議事録の場合はWordファイルのバイトデータ、QAの場合はExcelファイルのバイトデータが返却される。",
    "",
    "----",
    "## post_login",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "このメソッドはFastAPIのPOSTエンドポイント '/login' に紐付けられており、ログインフォームから送信されたユーザー名とパスワードを受け取ります。session_manager.login(username, password)で認証を行い、成功した場合は、ユーザーがログイン前にアクセスしようとしていたURL（pre_login_urlクッキーの値、なければ'/'）へ303リダイレクトします。その際、session_idクッキーをセットします。認証失敗時は、login.htmlテンプレートをエラー付きで再表示します。エッジケースとして、pre_login_urlクッキーが存在しない場合は'/'にリダイレクトされます。フォーム値が空の場合や認証失敗時は必ずエラー画面が表示されます。",
    "### 入力",
    "",
    "---",
    "  - req: Request",
    "  - username: str",
    "  - password: str",
    "### 出力",
    "",
    "---",
    "ログイン成功時はRedirectResponse（リダイレクト先URLとsession_idクッキー付き）、失敗時はTemplateResponse（login.htmlテンプレートとエラーメッセージ付き）を返します。例: 成功時はユーザーが元々アクセスしようとしていたページ（pre_login_urlクッキーの値、なければ'/'）へリダイレクトされ、失敗時はエラー付きログイン画面が再表示されます。",
    "",
    "----",
    "## encrypt_bytes",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、raw_bytesで与えられたバイト列データを、pwで指定されたパスワードを用いてAES方式で暗号化し、その結果をバイト列として返します。内部的にはpyAesCryptライブラリのencryptStream関数を利用しており、暗号化処理はメモリ上で完結します。呼び出し時には、パスワードが空でないことをassert文で検証しており、空の場合はAssertionErrorが発生します。主にファイルや通信データの安全な保存・送信のために利用されます。エッジケースとして、raw_bytesが空（b''）の場合でも、暗号化処理は正常に行われ、暗号化済みのバイト列が返されます。pwが空文字列の場合は例外が発生し、関数は実行されません。",
    "### 入力",
    "",
    "---",
    "  - raw_bytes: bytes",
    "  - pw: str",
    "### 出力",
    "",
    "---",
    "暗号化されたバイト列を返します。例えば、b'\\x00\\x01\\x02...（バイナリデータ）' のような、pyAesCryptで暗号化されたデータとなります。",
    "",
    "----",
    "## decrypt_bytes",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、pyAesCryptで暗号化されたバイト列（encrypted_bytes）を、指定されたパスワード（pw）を用いて復号し、元のバイト列を返します。パスワードが空の場合はアサーションエラーとなります。内部的にはio.BytesIOを使ってストリームとして処理し、pyAesCrypt.decryptStreamで復号を行います。復号に成功すると、復号化されたバイト列を返します。主にファイルやデータの安全な復号処理に利用されます。エッジケースとして、パスワードが空の場合は即座にAssertionErrorが発生し、パスワードが間違っている、または暗号化データが壊れている場合はpyAesCryptの例外が発生します。",
    "### 入力",
    "",
    "---",
    "  - encrypted_bytes: bytes",
    "  - pw: str",
    "### 出力",
    "",
    "---",
    "復号化されたバイト列。例えば、元のテキストファイルの内容（例: b'username: admin\\npassword: 1234'）など。",
    "",
    "----",
    "## encrypt_access_info",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "encrypt_access_info関数は、指定されたファイルパス（access_info_file）からアクセス情報をバイナリモードで読み込み、環境変数ENCRYPTION_KEYに格納されたパスワードを取得します。その後、encrypt_bytes関数を用いてファイル内容を暗号化し、暗号化されたバイト列をoutput_pathで指定されたファイルにバイナリモードで書き込みます。主にコマンドラインから呼び出され、ファイルの安全な保存や転送を目的としています。ファイルが存在しない場合や、環境変数が未設定の場合、または暗号化処理でエラーが発生した場合は例外が発生します。ファイルサイズが大きい場合でも全体をメモリに読み込むため、メモリ不足に注意が必要です。",
    "### 入力",
    "",
    "---",
    "  - access_info_file: str",
    "  - output_path: str",
    "### 出力",
    "",
    "---",
    "なし",
    "",
    "----",
    "## check_access_info",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、環境変数で指定された暗号化済みのアクセス情報ファイル（ACCESS_INFO_FILE）を復号し、JSON形式で格納されたユーザー情報から、指定されたユーザー名とパスワードが一致するかを検証します。認証に成功した場合は、ユーザー名とそのユーザーに紐づく追加情報（dataフィールドが存在する場合）を含む辞書を返します。認証に失敗した場合（ユーザーが存在しない、またはパスワードが一致しない場合）はNoneを返します。パスワードの復号にはENCRYPTION_KEY環境変数が使われ、キーが4文字以下の場合はAssertionErrorが発生します。ファイルが存在しない場合や復号・JSONデコードに失敗した場合は例外が発生します。エッジケースとして、ユーザー情報にdataフィールドが存在しない場合は空の辞書が返されます。",
    "### 入力",
    "",
    "---",
    "  - username: str",
    "  - password: str",
    "### 出力",
    "",
    "---",
    "認証に成功した場合はユーザー情報を含む辞書を返す。例: {\"username\": \"alice\", \"email\": \"alice@example.com\", \"role\": \"admin\"}。認証に失敗した場合はNoneを返す。",
    "",
    "----",
    "## extract_speakers",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、IR（投資家向け広報）会議の文字起こしデータ（transcribed_meeting）を受け取り、各話者の発言を集約します。話者IDごとに発言をまとめた後、AzureOpenAILLM（GPT-4-Oモデル）を利用して、各話者がIRチームのメンバーか投資家かを分類します。分類結果は、話者IDをキー、分類（\"Investor\"または\"IR\"）を値とするJSON形式の辞書として返されます。",
    "",
    "呼び出し方法：transcribed_meeting（List[Dict[str, Any]]型）を引数として渡して呼び出します。",
    "",
    "エッジケース：",
    "- transcribed_meeting内の各辞書に\"SpeakerId\"がない場合は\"speaker\"キーと\"text\"キーを利用します。",
    "- 発言が非常に長い場合は先頭1000文字のみをAIモデルに渡します。",
    "- transcribed_meetingが空の場合、AIモデルには空の入力が渡され、空の分類結果が返る可能性があります。",
    "- 辞書に必要なキーが欠落している場合、KeyErrorが発生する可能性があります。",
    "",
    "入力パラメータ：transcribed_meeting（List[Dict[str, Any]]）",
    "戻り値：dict<str, str>（話者IDと分類の辞書）",
    "例外：環境変数が未設定の場合や、AIモデルのAPI通信失敗時に例外が発生します。",
    "### 入力",
    "",
    "---",
    "  - transcribed_meeting: List[Dict[str, Any]]",
    "  例:",
    "```python",
    "[",
    "    {",
    "        \"SpeakerId\": \"Speaker-1\",",
    "        \"DisplayText\": \"本日の議題は...\"",
    "    },",
    "    {",
    "        \"speaker\": \"Speaker-2\",",
    "        \"text\": \"今後の業績について教えてください\"",
    "    }",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "各話者IDをキー、話者の分類（\"Investor\"または\"IR\"）を値とする辞書。例: {\"Speaker-1\": \"Investor\", \"Speaker-2\": \"IR\"} のような形式。",
    "",
    "----",
    "## is_qa_relevent",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、与えられたQ&Aペア（辞書型）が有効かつ関連性があるかどうかを判定します。判定基準は、\"question_report\"と\"answer_report\"の両方が空でなく、かつ\"topic\"がextract_qa_topic.IRRELEVENT_TOPICでない場合にTrueを返します。主にIR（投資家向け説明会）などの議事録生成やQ&A抽出処理の中で、関連性のあるQ&Aのみを抽出するために利用されます。呼び出し方法は、Q&Aペアの辞書を引数として渡すだけです。エッジケースとして、\"question_report\"や\"answer_report\"が空文字列やNoneの場合、また\"topic\"がextract_qa_topic.IRRELEVENT_TOPICと等しい場合はFalseを返します。辞書に必要なキーが存在しない場合は例外が発生します。",
    "### 入力",
    "",
    "---",
    "  - qa_pair: Dict[str, Any]",
    "  例:",
    "```python",
    "{",
    "    \"question_report\": \"今期の売上見通しは？\",",
    "    \"answer_report\": \"売上は前年比10%増を見込んでいます。\",",
    "    \"topic\": \"業績見通し\"",
    "}",
    "```",
    "### 出力",
    "",
    "---",
    "Q&Aペアが関連性がある場合はTrue、関連性がない場合はFalseを返します。例えば、{ \"question_report\": \"今期の売上見通しは？\", \"answer_report\": \"売上は前年比10%増を見込んでいます。\", \"topic\": \"業績見通し\" } の場合はTrue、{ \"question_report\": \"\", \"answer_report\": \"\", \"topic\": \"IRRELEVENT_TOPIC\" } の場合はFalseとなります。",
    "",
    "----",
    "## transcribe_audio_cloud",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "transcribe_audio_cloud関数は、指定されたファイルパス（video_file_path）にある音声または動画ファイルをテキストに変換します。ファイルの拡張子が'.wav'でない場合は、まず動画ファイルから音声トラックを抽出し、.wav形式の音声ファイルを生成します（例: 'sample.mp4' → 'sample.wav'）。その後、Azure Speechサービスを利用して音声認識を行い、音声内容をテキストとして抽出します。wavファイルが直接指定された場合は、そのまま音声認識処理に進みます。主に議事録作成や音声データの文字起こし用途で利用されます。エッジケースとして、存在しないファイルパスや非対応フォーマット、音声抽出や認識処理中のエラーが発生した場合は例外が発生します。",
    "### 入力",
    "",
    "---",
    "  - video_file_path: str",
    "### 出力",
    "",
    "---",
    "音声ファイルから抽出・変換されたテキストデータを表す文字列。例: '本日はご参加いただきありがとうございます。' など。",
    "",
    "----",
    "## create_gijiroku_data",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "create_gijiroku_dataは、指定された音声または動画ファイルのパスを受け取り、その内容をテキストに変換し、発言者の識別、発言コメントの抽出、Q&Aペアの生成、トピック分類、レポート形式への変換までを一括して行い、議事録データを辞書形式で返す関数です。主に会議やインタビューなどの音声記録から自動的に議事録を作成する用途で利用されます。呼び出しは video_file_path を引数にして行います。ファイルパスが無効、または音声認識や各種処理でエラーが発生した場合は例外が発生します。入力ファイルが空の場合や音声が認識できない場合、空のコメントやQ&Aリストが返されることがあります。",
    "### 入力",
    "",
    "---",
    "  - video_file_path: str",
    "### 出力",
    "",
    "---",
    "議事録データを含む辞書。'comments'キーには発言コメントのリスト、'QAs'キーにはQ&A形式の議事録データが格納される。例: {\"comments\": [\"発言1\", \"発言2\"], \"QAs\": [{\"question\": \"質問内容\", \"answer\": \"回答内容\", \"topic\": \"トピック名\"}]}",
    "",
    "----",
    "## identify_topics_in_qa_pairs",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、IR（投資家向け広報）チームと投資家の間で行われた質疑応答（QA）ペアのリストを受け取り、それぞれのペアに対して投資家視点で関連するトピックを抽出します。各ペアは 'question' と 'answer' のキーを持つ辞書で表現されており、関数はこれらを1件ずつ処理します。処理には大規模言語モデル（llm）を利用し、事前に定義されたプロンプトを用いてトピックを日本語で抽出します。抽出されたトピックは 'topic' キーとして各ペアの辞書に追加されます。もし質問・回答がIRチームにとって無関係な内容（例: 雑談や会議の技術的な話題など）であれば、'__not_relevant__' という特別なトピックが付与されます。",
    "",
    "関数は全てのペアを順に処理し、トークン使用量も合算しますが、返り値には含まれません。入力リストの各要素が 'question' および 'answer' キーを持たない場合や、llmのAPI呼び出しでエラーが発生した場合は例外が発生します。",
    "",
    "エッジケースとして、入力リストが空の場合は空リストを返します。また、各ペアの 'question' または 'answer' が空文字列の場合でもllmに問い合わせが行われ、適切なトピックまたは '__not_relevant__' が返されます。",
    "### 入力",
    "",
    "---",
    "  - qa_json: List[Dict[str, str]]",
    "  例:",
    "```python",
    "[",
    "    {",
    "        \"question\": \"今期の売上高は？\",",
    "        \"answer\": \"今期の売上高は100億円です。\"",
    "    }",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "各質問回答ペアの辞書に 'topic' キー（例: '業績', '株主還元', '__not_relevant__' など）が追加されたリスト。例: [{\"question\": \"今期の売上高は？\", \"answer\": \"今期の売上高は100億円です。\", \"topic\": \"業績\"}, ...]",
    "",
    "----",
    "## extract_comments",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、IRミーティングの逐語録データ（transcribed_meeting）から、投資家によるコメントやフィードバックを自動的に抽出し、内容ごとに分類・整理して返す。発話情報から話者を特定し、連続する同一話者の発話を結合した上で、最大40発話ごとにLLM（大規模言語モデル）へプロンプトを送信し、コメント抽出を行う。初回はsystem_promptとuser_prompt_firstを用い、2回目以降は直前の5発話分をコンテキストとして追加する。抽出結果はカテゴリ・クラスごとにまとめられ、全体のコメントリストとして返却される。JSONデコードエラーが発生した場合は最大3回までリトライし、失敗時は例外を出力して処理を中断する。入力データに話者IDやテキストが欠落している場合も柔軟に対応し、既知でない話者IDは\"Unknown\"として扱う。LLMの応答が不正な場合やAPI通信エラー時には例外処理が行われる。",
    "### 入力",
    "",
    "---",
    "  - transcribed_meeting: List[Dict[str, Any]]",
    "  - speaker_classes: Dict[str, str]",
    "  例:",
    "```python",
    "[",
    "    [",
    "        {",
    "            \"SpeakerId\": \"A\",",
    "            \"DisplayText\": \"御社の業績について質問があります。\"",
    "        },",
    "        {",
    "            \"speaker\": \"B\",",
    "            \"text\": \"今後の戦略についてコメントします。\"",
    "        }",
    "    ],",
    "    {",
    "        \"A\": \"IR\",",
    "        \"B\": \"Investor\"",
    "    }",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "抽出された投資家コメントのリスト。各要素は、{ \"topic\": \"業績見通しに関する議論\", \"class\": \"positive_comment\", \"category\": \"performance_and_outlook\", \"content\": \"2024年度の売上成長率が業界平均を上回っている点が評価される。\" } のような辞書。",
    "",
    "----",
    "## fix_conv_format",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "fix_conv_format関数は、音声認識などで得られた逐語録データ（transcribed_meeting）を、指定された話者クラス（speaker_classes）に基づいて会話形式に整形し、さらにAI（大規模言語モデル）を用いて誤認識や話者分割の誤り、句読点の欠落、単語の誤りなどを修正した会話リストを返します。主な処理は以下の通りです。",
    "",
    "1. transcribed_meetingの各発話を、speaker_classesで指定された話者クラス名に変換し、同じ話者が連続している場合は発話を結合してconversationリストを作成します。",
    "2. conversationリストを20件ずつ分割し、AI（llm.process_data）に渡して修正を行います。最初の20件はuser_prompt_first、それ以降はuser_prompt_followingを使い、前回の最後の発話を次のバッチの先頭に含めて文脈を維持します。",
    "3. AIからの応答がJSONとしてパースできない場合は最大3回までリトライし、それでも失敗した場合は処理を中断します。",
    "4. 全ての修正済み会話をconversation_itemsとしてまとめて返します。",
    "",
    "エッジケースとして、transcribed_meetingが空の場合は空リストを返します。また、AI応答が不正な場合やJSONパースに失敗した場合は、例外を出力し、途中までの結果を返します。話者IDや発話内容のキーが想定と異なる場合（例: 'SpeakerId'や'DisplayText'が存在しない場合）は、'speaker'や'text'を参照しますが、どちらもない場合はKeyErrorとなります。",
    "",
    "この関数は、IR（投資家向け広報）チームと投資家の会話記録を正確に修正・整形するために利用されます。",
    "### 入力",
    "",
    "---",
    "  - transcribed_meeting: List[Dict[str, Any]]",
    "  - speaker_classes: Dict[str, str]",
    "  例:",
    "```python",
    "[",
    "    [",
    "        {",
    "            \"SpeakerId\": \"1\",",
    "            \"DisplayText\": \"昨年の売上は\"",
    "        },",
    "        {",
    "            \"SpeakerId\": \"2\",",
    "            \"DisplayText\": \"どのくらい伸びましたか？\"",
    "        }",
    "    ],",
    "    {",
    "        \"1\": \"Investor\",",
    "        \"2\": \"IR\"",
    "    }",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "修正済み会話データのリスト。各要素は辞書で、'speaker'（話者クラス名）と'content'（発話内容）を持つ。例: [{\"speaker\": \"Investor\", \"content\": \"昨年の売上はどのくらい伸びましたか？\"}, {\"speaker\": \"IR\", \"content\": \"売上は25%増加しました。\"}]",
    "",
    "----",
    "## extract_qa_pairs",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、IRチームと投資家の会議書き起こしデータ（transcribed_meeting）から、質問と回答のペア（QAペア）を抽出します。まず、各発言を話者ごとにまとめ、話者クラス（\"IR\"や\"Investor\"）を判定します。発言が連続して同じ話者の場合は内容を結合します。その後、20発言ごとに会話を分割し、LLM（大規模言語モデル）を用いてQAペアを抽出します。最初の分割ではuser_prompt_firstを、2回目以降はuser_prompt_followingと前回の最後のQAペアを使ってプロンプトを生成し、モデルに渡します。モデルからの応答をJSONとしてパースし、QAペアをリストに追加します。JSONDecodeErrorが発生した場合は最大3回までリトライし、失敗した場合は例外情報を出力して処理を中断します。全てのQAペアを抽出した後、リストとして返します。エッジケースとして、発言情報のキーが異なる場合（\"SpeakerId\"/\"speaker\"や\"DisplayText\"/\"text\"/\"content\"）にも対応し、会話の途中で切れていても部分的なQAペアを返します。",
    "### 入力",
    "",
    "---",
    "  - transcribed_meeting: List[Dict[str, Any]]",
    "  - speaker_classes: Dict[str, str]",
    "  例:",
    "```python",
    "[",
    "    [",
    "        {",
    "            \"SpeakerId\": \"A\",",
    "            \"DisplayText\": \"昨年の売上は？\"",
    "        },",
    "        {",
    "            \"speaker\": \"B\",",
    "            \"text\": \"25%増加しました。\"",
    "        }",
    "    ],",
    "    {",
    "        \"A\": \"Investor\",",
    "        \"B\": \"IR\"",
    "    }",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "会話から抽出されたQAペアのリスト。各要素は {\"question\": \"Investor: 昨年の売上はどのくらい伸びましたか？\", \"answer\": \"IR: 売上は25%増加しました。\"} のような辞書。例: [ {\"question\": \"Investor: 昨年の売上はどのくらい伸びましたか？\", \"answer\": \"IR: 売上は25%増加しました。\"}, {\"question\": \"Investor: 来年の見込みはどうですか？\", \"answer\": \"IR: 来年の見込みとしては、20%の増加を目指しています。\"} ]",
    "",
    "----",
    "## transform_qa_to_report",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、IR（投資家向け広報）ミーティングの質疑応答ペア（質問と回答のセット）を受け取り、それぞれのペアをレポート形式の文章に変換します。入力は、'question'と'answer'を持つ辞書のリストです。各ペアごとに、AzureOpenAILLMインスタンス（llm）を用いて、事前定義されたsystem_promptとuser_promptを組み合わせてLLMに投げ、整形済みの質問（'question_report'）と回答（'answer_report'）をJSON形式で取得します。元のペアにこの整形済み情報をマージし、全てのペアを処理したリストを返します。",
    "",
    "呼び出し方法は、IRミーティングの質疑応答データ（リスト形式）を引数として渡すだけです。",
    "",
    "エッジケースとして、",
    "- qa_jsonが空リストの場合は空リストを返します。",
    "- 各ペアの'dict'に'question'や'answer'が欠けている場合、KeyErrorが発生します。",
    "- LLMのAPI呼び出しでエラーが発生した場合、例外がそのまま伝播します。",
    "- LLMの応答が不正なJSONの場合、json()呼び出し時に例外が発生します。",
    "",
    "この関数は、IRレポート作成や議事録整形の自動化に利用できます。",
    "### 入力",
    "",
    "---",
    "  - qa_json: List[Dict[str, str]]",
    "  例:",
    "```python",
    "[",
    "    {",
    "        \"question\": \"昨年の売上はどのくらい伸びましたか？\",",
    "        \"answer\": \"売上は25%増加しました。\"",
    "    }",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "各質疑応答ペアに対して、元の'question'と'answer'に加え、'question_report'（整形済みの質問文）と'answer_report'（整形済みの回答文リスト）を追加した辞書のリスト。例: [{'question': '昨年の売上はどのくらい伸びましたか？', 'answer': '売上は25%増加しました。', 'question_report': '昨年の売上はどのくらい伸びましたか？', 'answer_report': ['売上は25%増加しました。']}]",
    "",
    "----",
    "## convert_format",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、'word_segments' というキーを持つ辞書（in_format_data）を受け取り、各発話単位（word_data）を発話者ごとにまとめて新しいリスト形式に変換します。'word_segments' の各要素は 'speaker'（発話者）と 'word'（発話内容）を持つ辞書です。speakerが連続して同じ場合はtextとして連結し、speakerが変わると新しい要素としてリストに追加します。最後に残った内容もリストに追加します。主に音声認識や会話記録のデータ整形に利用されます。",
    "",
    "エッジケースとして、'word_segments' の要素に 'speaker' キーがない場合は直前のspeakerを引き継ぎます。'word_segments' が空の場合や、'speaker' 情報が最初から存在しない場合は、Noneがspeakerとして扱われます。in_format_data自体に'word_segments'キーがない場合や、word_dataに'word'キーがない場合はKeyError例外が発生します。",
    "",
    "この関数は直接呼び出して利用します。",
    "### 入力",
    "",
    "---",
    "  - in_format_data: Dict[str, Any]",
    "  例:",
    "```python",
    "{",
    "    \"word_segments\": [",
    "        {",
    "            \"speaker\": \"A\",",
    "            \"word\": \"こんにちは\"",
    "        },",
    "        {",
    "            \"word\": \"ありがとう\"",
    "        }",
    "    ]",
    "}",
    "```",
    "### 出力",
    "",
    "---",
    "発話者ごとにまとめられた発話内容のリスト。各要素は {'speaker': 'A', 'text': 'こんにちはありがとう'} のような辞書。例: [{'speaker': 'A', 'text': 'こんにちは'}, {'speaker': 'B', 'text': 'ありがとう'}]",
    "",
    "----",
    "## clean_up",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、会話データ（発言者と発言内容の辞書のリスト）を受け取り、同じ発言者による連続した発言や、5文字未満の短い発言を直前の発言に結合することで、より読みやすく整理された会話データを返します。最初の発言はそのまま追加されますが、2つ目以降の発言については、直前の発言者と同じ場合、または発言内容が5文字未満の場合は、直前の発言の'text'に結合されます。それ以外の場合は新しい発言として追加されます。主に音声認識や議事録作成などで、断片的な発言をまとめて見やすくするために利用されます。エッジケースとして、空リストが渡された場合は空リストを返します。全ての発言が5文字未満の場合や、全て同じ発言者の場合も正しく結合されます。",
    "### 入力",
    "",
    "---",
    "  - dirty_data: List[Dict[str, str]]",
    "  例:",
    "```python",
    "[",
    "    {",
    "        \"speaker\": \"IR担当者\",",
    "        \"text\": \"本日はよろしくお願いします。\"",
    "    },",
    "    {",
    "        \"speaker\": \"IR担当者\",",
    "        \"text\": \"早速ですが、決算についてご説明します。\"",
    "    },",
    "    {",
    "        \"speaker\": \"投資家\",",
    "        \"text\": \"ありがとうございます。\"",
    "    }",
    "]",
    "```",
    "### 出力",
    "",
    "---",
    "会話データのリスト（List[Dict[str, str]]）。連続する同一発言者の発言や5文字未満の短い発言が前の発言に結合された新しいリスト。例: [{'speaker': 'IR担当者', 'text': '本日はよろしくお願いします。早速ですが、決算についてご説明します。'}, {'speaker': '投資家', 'text': 'ありがとうございます。'}]",
    "",
    "----",
    "## extract_audio_track",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、ffmpegコマンドラインツールを利用して、指定された動画ファイル（video_file_path）から音声トラックのみを抽出し、16kHz・モノラル・PCM形式（wavファイル）でoriginal_audio_pathに保存します。関数はsubprocess.callを用いてシェルコマンドを実行します。主に音声認識や文字起こしなど、音声データのみが必要な場合に利用されます。呼び出しはextract_audio_track('/path/to/video.mp4', '/path/to/audio.wav')のように行います。エッジケースとして、video_file_pathが存在しない場合やffmpegがインストールされていない場合、またはoriginal_audio_pathのディレクトリに書き込み権限がない場合、コマンド実行は失敗しますが、関数自体は例外をスローせず、戻り値もありません（subprocess.callの戻り値も返しません）。そのため、呼び出し元でエラー処理を行う必要があります。",
    "### 入力",
    "",
    "---",
    "  - video_file_path: str",
    "  - original_audio_path: str",
    "### 出力",
    "",
    "---",
    "なし",
    "",
    "----",
    "## health_check_local_server",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、環境変数 'LOCAL_AI_SERVER_ADDRESS' で指定されたローカルAIサーバーのアドレスと、'LOCAL_AI_SERVER_PORT'（デフォルトは3101）で指定されたポートを用いて、'/api/v1/health_check' エンドポイントにGETリクエストを送信します。リクエストには 'LOCAL_AI_SERVER_KEY' の値を 'Authorization' ヘッダーとして付与します。サーバーからのレスポンスのHTTPステータスコードが200の場合はTrueを返し、それ以外の場合や 'LOCAL_AI_SERVER_ADDRESS' が未設定の場合はFalseを返します。主にサーバーの稼働確認や疎通確認のために利用されます。エッジケースとして、環境変数が未設定の場合やサーバーがダウンしている場合、ネットワーク障害時にはFalseを返しますが、requests.get()で例外が発生した場合は例外がそのままスローされます。",
    "### 入力",
    "",
    "---",
    "  なし",
    "### 出力",
    "",
    "---",
    "サーバーが正常に稼働している場合はTrue、そうでない場合はFalseを返します。例: True",
    "",
    "----",
    "## speech_to_text_local_server",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、指定された音声ファイル（original_audio_path）をバイナリとして読み込み、base64エンコードした上でローカルAIサーバー（環境変数で指定）にPOSTリクエストを送信し、文字起こしタスクを登録します。with_diarizationがTrueの場合は話者分離付きで、Falseの場合は通常の文字起こしモードでリクエストします。タスク登録後、定期的にGETリクエストでタスクの状態をポーリングし、完了または失敗まで待機します。完了時には結果を取得し、辞書形式で返します。失敗やサーバーエラー時にはAiServerError例外を発生させるか、AiServerErrorインスタンスを返します。エッジケースとして、サーバーが見つからない、認証キーが不正、タスクが失敗した場合などに適切なエラー処理が行われます。",
    "### 入力",
    "",
    "---",
    "  - original_audio_path: str",
    "  - with_diarization: bool",
    "  - prompt: str",
    "### 出力",
    "",
    "---",
    "サーバーから返却された文字起こし結果などの情報を含む辞書。例: {\"text\": \"会議の内容...\", \"segments\": [{\"speaker\": \"A\", \"text\": \"こんにちは\"}, ...], \"process_id\": \"abc123\", \"state\": \"finished\"}。エラー時はAiServerErrorインスタンスを返す場合もあります。",
    "",
    "----",
    "## speech_to_text_azure",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、original_audio_pathで指定された音声ファイルをAzure Cognitive Services Speech SDKのConversationTranscriberを利用して日本語（ja-JP）で文字起こしを行います。AzureのAPIキーとリージョンは環境変数（SPEECH_API_KEY, SPEECH_API_REGION）から取得します。話者識別（DifferentiateGuestSpeakers）を有効にしており、複数話者の会話にも対応します。音声認識の結果はイベントハンドラで受け取り、JSON形式でall_resultsリストに格納されます。関数は非同期で文字起こしを開始し、セッション終了またはキャンセルイベントを受けるまで待機し、全ての認識結果をリストで返します。",
    "",
    "エッジケースとして、無音や認識できない音声ファイルの場合は空リストが返ることがあります。また、APIキーやリージョンが未設定、ファイルパスが不正、ネットワーク障害、Azure側のエラーなどが発生した場合は例外がスローされます。",
    "### 入力",
    "",
    "---",
    "  - original_audio_path: str",
    "### 出力",
    "",
    "---",
    "音声認識結果のリスト。各要素はdict型で、Azure Speech SDKの認識結果をJSONとしてパースしたものです。例: [{\"Text\": \"こんにちは。\", \"SpeakerId\": \"1\", \"Duration\": 12345, ...}, {\"Text\": \"よろしくお願いします。\", \"SpeakerId\": \"2\", \"Duration\": 6789, ...}]",
    "",
    "----",
    "## speech_to_text",
    "",
    "---",
    "### 説明",
    "",
    "---",
    "この関数は、音声ファイル（original_audio_path）をテキストに変換するためのラッパー関数です。まずhealth_check_local_server()でローカルAIサーバーの稼働状況を確認し、稼働していればspeech_to_text_local_server()を呼び出して音声認識を行い、その結果をconvert_format()で整形し、clean_up()で後処理をして返します。ローカルサーバーが利用できない場合は、Azureの音声認識サービス（speech_to_text_azure()）を利用します。with_diarization引数で話者分離の有無を制御でき、prompt引数で認識精度向上のための文脈を指定できます。エッジケースとして、ローカルサーバーやAzureサービスが利用できない場合や、音声ファイルが存在しない場合、または認識処理中にエラーが発生した場合は例外が発生します。",
    "### 入力",
    "",
    "---",
    "  - original_audio_path: str",
    "  - with_diarization: bool",
    "  - prompt: str",
    "  例:",
    "```python",
    "{",
    "    \"audio_path\": \"/data/audio/meeting1.wav\",",
    "    \"enable_diarization\": true,",
    "    \"prompt\": \"下記は、IR担当者と投資家が会社について話し合う会議の会話です。\"",
    "}",
    "```",
    "### 出力",
    "",
    "---",
    "音声認識結果を含む辞書。例: {\"text\": \"本日はご参加いただきありがとうございます。\", \"segments\": [{\"speaker\": \"A\", \"text\": \"こんにちは。\"}, {\"speaker\": \"B\", \"text\": \"よろしくお願いします。\"}]}",
    ""
  ]
}